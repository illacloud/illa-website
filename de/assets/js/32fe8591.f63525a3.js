"use strict";(self.webpackChunkilla_website=self.webpackChunkilla_website||[]).push([[2409],{8293:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>l});var i=r(1527),t=r(7214);const o={},s=void 0,d={permalink:"/de/blog/react-error-boundary/react-error-boundary",source:"@site/i18n/de/docusaurus-plugin-content-blog/react-error-boundary/react-error-boundary.md",title:"react-error-boundary/react-error-boundary",description:"---",date:"2024-12-02T07:35:41.000Z",formattedDate:"2. Dezember 2024",tags:[],readingTime:14.32,hasTruncateMarker:!1,authors:[],frontMatter:{},unlisted:!1,nextItem:{title:"Verwendung von Remark zur Erstellung eines interaktiven Inhaltsverzeichnisses in einem Next.js-Blog",permalink:"/de/blog/react-markdown"},relatedPosts:[],authorPosts:[]},a={authorsImageUrls:[]},l=[{value:"slug: react-error-boundary\ntitle: &quot;React-Fehlergrenze: Wie man React-Fehler effektiver behandeln kann&quot;\ndescription: Durch die Verwendung von react-error-boundary in Ihrer React-Anwendung wird eine leistungsstarke Fehlerbehandlung und eine einfachere Debugging m\xf6glich. Mit dieser Bibliothek k\xf6nnen Sie Zeit f\xfcr das Fehlermanagement sparen und sich auf das Aufbauen hervorragender Produktfunktionen konzentrieren.\nauthors: [owen]\nimage: https://cdn.illacloud.com/illa-website/blog/react-error-boundary/cover.webp\ntags: [react, Komponenten, Bibliothek]\ndate: 2024-02-27T10:00",id:"slug-react-error-boundarytitle-react-fehlergrenze-wie-man-react-fehler-effektiver-behandeln-kanndescription-durch-die-verwendung-von-react-error-boundary-in-ihrer-react-anwendung-wird-eine-leistungsstarke-fehlerbehandlung-und-eine-einfachere-debugging-m\xf6glich-mit-dieser-bibliothek-k\xf6nnen-sie-zeit-f\xfcr-das-fehlermanagement-sparen-und-sich-auf-das-aufbauen-hervorragender-produktfunktionen-konzentrierenauthors-owenimage-httpscdnillacloudcomilla-websiteblogreact-error-boundarycoverwebptags-react-komponenten-bibliothekdate-2024-02-27t1000",level:2},{value:"Was ist eine React-Fehlergrenze?",id:"was-ist-eine-react-fehlergrenze",level:2},{value:"Grundlegende Verwendung",id:"grundlegende-verwendung",level:2},{value:"Fehlergrenze Implementierung: Allgemeine Designmuster",id:"fehlergrenze-implementierung-allgemeine-designmuster",level:3},{value:"Komponentenlevel-Fehlergrenze",id:"komponentenlevel-fehlergrenze",level:3},{value:"Top-Level Error Boundaries",id:"top-level-error-boundaries",level:3},{value:"Using the <code>react-error-boundary</code> Library",id:"using-the-react-error-boundary-library",level:2},{value:"ErrorBoundary Component",id:"errorboundary-component",level:2},{value:"useErrorHandler Hook",id:"useerrorhandler-hook",level:3},{value:"withErrorBoundary HOC",id:"witherrorboundary-hoc",level:2},{value:"Vorteile",id:"vorteile",level:2},{value:"Fazit",id:"fazit",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.h2,{id:"slug-react-error-boundarytitle-react-fehlergrenze-wie-man-react-fehler-effektiver-behandeln-kanndescription-durch-die-verwendung-von-react-error-boundary-in-ihrer-react-anwendung-wird-eine-leistungsstarke-fehlerbehandlung-und-eine-einfachere-debugging-m\xf6glich-mit-dieser-bibliothek-k\xf6nnen-sie-zeit-f\xfcr-das-fehlermanagement-sparen-und-sich-auf-das-aufbauen-hervorragender-produktfunktionen-konzentrierenauthors-owenimage-httpscdnillacloudcomilla-websiteblogreact-error-boundarycoverwebptags-react-komponenten-bibliothekdate-2024-02-27t1000",children:['slug: react-error-boundary\ntitle: "React-Fehlergrenze: Wie man React-Fehler effektiver behandeln kann"\ndescription: Durch die Verwendung von react-error-boundary in Ihrer React-Anwendung wird eine leistungsstarke Fehlerbehandlung und eine einfachere Debugging m\xf6glich. Mit dieser Bibliothek k\xf6nnen Sie Zeit f\xfcr das Fehlermanagement sparen und sich auf das Aufbauen hervorragender Produktfunktionen konzentrieren.\nauthors: [owen]\nimage: ',(0,i.jsx)(n.a,{href:"https://cdn.illacloud.com/illa-website/blog/react-error-boundary/cover.webp",children:"https://cdn.illacloud.com/illa-website/blog/react-error-boundary/cover.webp"}),"\ntags: [react, Komponenten, Bibliothek]\ndate: 2024-02-27T10:00"]}),"\n",(0,i.jsx)(n.p,{children:"Beim Aufbau einer Anwendung ist es unvermeidlich, dass Fehler auftreten. Selbst mit den besten Codierungspraktiken kann es zu unerwarteten Laufzeitfehlern kommen, die die Anwendung zum Absturz bringen. Daher ist die Fehlerbehandlung sehr wichtig. In diesem Artikel werden wir uns mit der Methode zur Erfassung und Behandlung von Fehlern in React besch\xe4ftigen und eine leistungsst\xe4rkere Methode f\xfcr die Behandlung von React-Fehlern vorstellen!"}),"\n",(0,i.jsx)(n.p,{children:"Warum ist es wichtig, Fehler in React zu erfassen? Seit React 16 f\xfchrt das Auftreten von Fehlern w\xe4hrend des Lebenszyklus dazu, dass die gesamte Anwendung unmontiert und abst\xfcrzt, wenn sie nicht erfasst werden. Fr\xfcher blieben kleine Fehler innerhalb von Komponenten auf dem Bildschirm, aber heute k\xf6nnen unerfasste Fehler von Drittanbieterbibliotheken, die nicht kontrolliert werden k\xf6nnen, einen Teil der Benutzeroberfl\xe4che oder die Seite zum Absturz bringen, ein wei\xdfes Bildschirm und beeintr\xe4chtigen die Benutzererfahrung. Daher ist es notwendig, Fehler in React zu erfassen und zu behandeln."}),"\n",(0,i.jsxs)(n.p,{children:["In JavaScript k\xf6nnen Sie Fehler mit ",(0,i.jsx)(n.code,{children:"try...catch"})," erfassen. Zum Beispiel:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'const fetchData = async () => {\n  try {\n    return await fetch("https://some-url-that-might-fail.com");   \n  } catch (error) {\n    console.error(error); \n    return error;\n  }\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"try...catch"})," ist gut f\xfcr imperativen Code geeignet, wie z.B. Datenabholung, aber nicht f\xfcr deklarativen Code wie JSX, der innerhalb von Komponenten geschrieben ist. Wie kann man dann Fehler in React erfassen? Gl\xfccklicherweise wurde mit React 16 das neue Konzept der React-Fehlergrenze eingef\xfchrt. Lassen Sie uns sehen, was das ist und wie man es verwendet."]}),"\n",(0,i.jsx)(n.h2,{id:"was-ist-eine-react-fehlergrenze",children:"Was ist eine React-Fehlergrenze?"}),"\n",(0,i.jsxs)(n.p,{children:["Eine React-Fehlergrenze ist eine Methode zur Behandlung von Fehlern in einer React-Anwendung. Sie dient dazu, JavaScript-Fehler irgendwo im Baum der Kinderkomponenten zu erfassen und diese zu loggen und stattdessen eine Fallback-UI anzuzeigen, anstatt den gesamten Baum der Komponenten (einen wei\xdfen Bildschirm) zu unmontieren. Sie sind wie ",(0,i.jsx)(n.code,{children:"catch {}"}),"-Bl\xf6cke in JavaScript, die nur auf Komponenten angewendet werden."]}),"\n",(0,i.jsx)(n.h2,{id:"grundlegende-verwendung",children:"Grundlegende Verwendung"}),"\n",(0,i.jsx)(n.p,{children:"Bevor Fehlergrenzen eingef\xfchrt wurden, w\xfcrden Fehler in Komponenten weitergegeben und letztendlich zu einem wei\xdfen Bildschirm oder einer falschen UI f\xfchren, was die Benutzererfahrung beeintr\xe4chtigt. Mit Fehlergrenzen k\xf6nnen Sie diese unverarbeiteten Fehler effektiv containerisieren und verwalten."}),"\n",(0,i.jsx)(n.p,{children:"Sie k\xf6nnen entweder eine Fehlergrenze f\xfcr die gesamte Anwendung einrichten oder eine detailliertere Kontrolle f\xfcr einzelne Komponenten haben. Fehlergrenzen erfassen nur Fehler, die w\xe4hrend der Rendering-, Lebenszyklusmethoden oder Konstruktoren auftreten, und erfassen nicht:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Ereignisbehandlungen (hier ist es erforderlich, normale ",(0,i.jsx)(n.code,{children:"try/catch"}),"-Bl\xf6cke zu verwenden)"]}),"\n",(0,i.jsxs)(n.li,{children:["Asynchroner Code (z.B. Callbacks von ",(0,i.jsx)(n.code,{children:"setTimeout"})," oder ",(0,i.jsx)(n.code,{children:"requestAnimationFrame"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"Serverseitige Rendering"}),"\n",(0,i.jsx)(n.li,{children:"Fehler, die innerhalb der Fehlergrenze selbst auftreten, nicht die Kinderkomponenten"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Um Fehlergrenzen in React v16 zu verwenden, m\xfcssen Sie eine Klassenkomponente definieren und eine oder beide der folgenden Lebenszyklusmethoden hinzuf\xfcgen:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"getDerivedStateFromError()"}),": Ein Lebenszyklus-Methode, die nach einem geworfenen Fehler aufgerufen wird, um die Fallback-UI f\xfcr das n\xe4chste Rendering zu aktualisieren. Sie wird w\xe4hrend der Renderingphase aufgerufen, daher sind Nebeneffekte nicht erlaubt."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"componentDidCatch()"}),": Eine Methode, die zum Protokollieren von Fehlerinformationen verwendet wird. Sie wird w\xe4hrend der Commit-Phase aufgerufen, daher k\xf6nnen Nebeneffekte ausgef\xfchrt werden."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Hier ist ein Beispiel einer ",(0,i.jsx)(n.code,{children:"ErrorBoundary"}),"-Klassenkomponente, die beide Lebenszyklusmethoden ",(0,i.jsx)(n.code,{children:"getDerivedStateFromError()"})," und ",(0,i.jsx)(n.code,{children:"componentDidCatch()"})," implementiert:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Aktualisieren Sie den Zustand, um die Fallback-UI im n\xe4chsten Rendering anzuzeigen.\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Rendern Sie die benutzerdefinierte Fallback-UI\n      return <h1>Oops! Etwas ist schiefgelaufen.</h1>;\n    }\n\n    return this.props.children; \n  }\n}\n\n// Verwendung in Komponenten\nclass App extends React.Component {\n  render() {\n    return (\n      <ErrorBoundary>\n        <MyComponent />\n      </ErrorBoundary>\n    );\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Hier ist die ",(0,i.jsx)(n.code,{children:"ErrorBoundary"}),"-Fehlergrenze definiert. Der Konstruktor initialisiert ein Zustandsobjekt und setzt die ",(0,i.jsx)(n.code,{children:"hasError"}),"-Eigenschaft auf ",(0,i.jsx)(n.code,{children:"false"}),", was bedeutet, dass es noch keine Fehler gab."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Die ",(0,i.jsx)(n.code,{children:"getDerivedStateFromError()"}),"-Methode wird aufgerufen, wenn ein Fehler abgefangen wird, und nimmt ein ",(0,i.jsx)(n.code,{children:"error"}),"-Objekt als Parameter entgegen und gibt ein neues Zustandsobjekt zur\xfcck. Dadurch wird die Fallback-UI im n\xe4chsten Rendering angezeigt."]}),"\n",(0,i.jsxs)(n.li,{children:["Die ",(0,i.jsx)(n.code,{children:"componentDidCatch()"}),"-Methode wird nach dem Abfangen eines Fehlers aufgerufen und protokolliert die Fehler- und Fehlerinformationen im Konsolenprotokoll."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In der ",(0,i.jsx)(n.code,{children:"render()"}),"-Methode wird basierend auf dem Wert von ",(0,i.jsx)(n.code,{children:"hasError"})," entschieden, ob die urspr\xfcnglichen Kinderkomponenten gerendert werden sollen oder die Fallback-UI. Wenn ",(0,i.jsx)(n.code,{children:"hasError"})," wahr ist, wird ",(0,i.jsx)(n.code,{children:"<h1>Oops! Etwas ist schiefgelaufen.</h1>"})," gerendert. Andernfalls werden die urspr\xfcnglichen Kinderkomponenten gerendert. Um eine Fehlergrenze in einer React-Komponente zu verwenden, wickeln Sie den zu sch\xfctzenden beliebigen Komponenten in ",(0,i.jsx)(n.code,{children:"<ErrorBoundary>"})," ein. Dadurch wird verhindert, dass ein Absturz eines kleinen Komponenten die gesamte Anwendung zum Absturz bringt, und es wird ein wei\xdfer Bildschirm entsteht. Nur der fehlerhafte Komponenten wird nicht ordnungsgem\xe4\xdf gerendert, und die Fallback-UI wird angezeigt, was es einfacher macht, das betroffene Komponentenproblem schnell zu identifizieren."]}),"\n",(0,i.jsx)(n.h3,{id:"fehlergrenze-implementierung-allgemeine-designmuster",children:"Fehlergrenze Implementierung: Allgemeine Designmuster"}),"\n",(0,i.jsx)(n.p,{children:"Beim Implementieren einer Fehlergrenze in React k\xf6nnen Sie eine der folgenden drei Designmuster verwenden."}),"\n",(0,i.jsx)(n.h3,{id:"komponentenlevel-fehlergrenze",children:"Komponentenlevel-Fehlergrenze"}),"\n",(0,i.jsx)(n.p,{children:"Dieses Ansatz erm\xf6glicht es, einzelne Komponenten in einer Fehlergrenze zu wickeln. Dadurch bietet es eine hohe Granularit\xe4t, um Fehler innerhalb jeder Komponente zu isolieren und zu behandeln. Wenn eine Komponente abst\xfcrzt, h\xe4lt die Fehlergrenze den Fehler ab und verhindert, dass er sich durch den Komponentenbaum ausbreitet. Das bedeutet, dass nur der abst\xfcrzende Komponenten betroffen ist und die restliche Anwendung normal ausgef\xfchrt wird."}),"\n",(0,i.jsx)(n.p,{children:"Komponentenlevel-Fehlergrenzen sind besonders n\xfctzlich, wenn Sie Komponenten haben, die voneinander unabh\xe4ngig sind und keinen Zustand teilen. Wenn eine Komponente das Rendering fehlschl\xe4gt, beeinflusst sie keine anderen Komponenten. Allerdings kann diese Methode potenziell viel redundanten Code verursachen, wenn viele Komponenten ihre eigenen Fehlergrenzen ben\xf6tigen."}),"\n",(0,i.jsx)(n.h3,{id:"top-level-error-boundaries",children:"Top-Level Error Boundaries"}),"\n",(0,i.jsx)(n.p,{children:"Top-Level Error Boundaries are placed at the very top of the component tree. They are a general solution for handling any errors within an application. This approach guarantees that no matter where an error occurs in the application, it can be caught and handled gracefully."}),"\n",(0,i.jsx)(n.p,{children:"This prevents the entire application from crashing when an error occurs. However, Top-Level Error Boundaries are the coarsest method. Errors can affect not only the component or group of components where the error occurred but also the entire application."}),"\n",(0,i.jsxs)(n.h2,{id:"using-the-react-error-boundary-library",children:["Using the ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," Library"]}),"\n",(0,i.jsxs)(n.p,{children:["As mentioned earlier, React Error Boundaries have some limitations and may not handle specific special cases. The following is a more powerful method for handling errors in React: the ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," library. This is a small React error handling library that provides enhanced functionality and a more flexible approach for processing errors in React applications, allowing developers to create more robust and user-friendly error handling mechanisms."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"react-error-boundary"})," adopts a more modern approach with React Hooks and functional components, aligning with the current trends in React development. It uses a simple component ",(0,i.jsx)(n.code,{children:"ErrorBoundary"})," to wrap potential errors."]}),"\n",(0,i.jsxs)(n.p,{children:["The props provided by ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," are as follows:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"FallbackComponent"}),": Used to specify a custom component to render when an error occurs within the error boundary. It provides flexibility to create a visually appealing and informative user interface to display errors and offer necessary actions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fallbackRender"}),": Similar to ",(0,i.jsx)(n.code,{children:"FallbackComponent"}),", this prop is used to define a custom rendering function for the error fallback interface. It allows for more control over the rendering process and enables more advanced error handling logic."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"onError"}),": Accepts a callback function that is invoked when the error boundary catches an error. It passes the error object and component stack trace information. Additional actions such as logging errors or sending error reports to external services can be performed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"onReset"}),": Accepts a callback function that is triggered after the error boundary has been successfully reset. It can be used to update the component's state or perform cleanup operations after the error has been recovered."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fallbackProps"}),": Allows passing additional ",(0,i.jsx)(n.code,{children:"props"})," to ",(0,i.jsx)(n.code,{children:"FallbackComponent"})," or ",(0,i.jsx)(n.code,{children:"fallbackRender"})," function. It can be used to provide context and additional data to the error fallback interface."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"retry"}),": A boolean value that determines whether the error boundary allows the operation that caused the error to be retried. If set to true, the ",(0,i.jsx)(n.code,{children:"resetErrorBoundary"})," function can be called from the error fallback interface to retry the operation."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"errorboundary-component",children:"ErrorBoundary Component"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ErrorBoundary"})," component provided by ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," has a prop ",(0,i.jsx)(n.code,{children:"fallbackRender"})," that accepts a function or React element to display when an error is caught. It also provides a prop ",(0,i.jsx)(n.code,{children:"resetKeys"})," that allows the component's state to be reset when specific props change."]}),"\n",(0,i.jsxs)(n.p,{children:["The charm of ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," is that it eliminates the need to manually write class components and manage state. Everything is done in the background, allowing developers to focus on building the application. Here is an example of using ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," in a component:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { ErrorBoundary } from 'react-error-boundary'\n\nfunction MyFallbackComponent({ error, resetErrorBoundary }) {\n  return (\n    <div role=\"alert\">\n      <p> Oops! Something went wrong:</p>\n      <pre>{error.message}</pre>\n      <button onClick={resetErrorBoundary}> Retry </button>\n    </div>\n  )\n}\n\nfunction MyComponent() {\n  // Component logic that may throw a JavaScript error\n}\n\nfunction App() {\n  return (\n    <ErrorBoundary\n      FallbackComponent={MyFallbackComponent}\n      onReset={() => {\n        // Clean up the application state\n      }}\n      resetKeys={['someKey']}\n    >\n      <MyComponent />\n    </ErrorBoundary>\n  )\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example, when ",(0,i.jsx)(n.code,{children:"ErrorBoundary"})," catches an error, it renders ",(0,i.jsx)(n.code,{children:"MyFallbackComponent"}),". It displays the error message and provides a button to reset the error state and attempt to re-render the component. The ",(0,i.jsx)(n.code,{children:"onReset"})," prop is used to perform cleanup actions after the error, and the ",(0,i.jsx)(n.code,{children:"resetKeys"})," prop is used to control the timing of when the component's state is reset."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"onError"})," prop of ",(0,i.jsx)(n.code,{children:"ErrorBoundary"})," is a function that is called every time an error is caught. This property can be used to report errors:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// Error reporting function\nfunction logErrorToService(error, info) {\n  // Error reporting logic...\n  console.error("Caught an error:", error, info);\n}\n\nfunction App() {\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      onError={logErrorToService}\n    >\n      <MyComponent />\n    </ErrorBoundary>\n  );\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["One of the most powerful features of ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," is the ability to reset the state of the error boundary. This allows errors to be cleared and the component tree to be re-rendered. This is very convenient when the error is likely temporary, such as a transient network error."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"resetErrorBoundary"})," function provided to the fallback component can be used to reset the error boundary. For example, this function can be called on a button click, allowing users to manually retry a failed operation."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ErrorBoundary"})," can accept a ",(0,i.jsx)(n.code,{children:"onReset"})," prop that is called before the error state is reset. This function is helpful for performing cleanup and state reset operations before the component is re-rendered after the error."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"resetKeys"})," prop is an array of values that reset the error boundary when a specific ",(0,i.jsx)(n.code,{children:"prop"})," or state value changes. This is convenient when a change in specific ",(0,i.jsx)(n.code,{children:"props"})," or state values resolves the error. Here is an example of how to use these properties:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { ErrorBoundary } from 'react-error-boundary'\n\nfunction ErrorFallback({ error, resetErrorBoundary }) {\n  return (\n    <div role=\"alert\">\n      <p> Oops! Something went wrong:</p>\n      <pre>{error.message}</pre>\n      <button onClick={resetErrorBoundary}> Retry </button>\n    </div>\n  )\n}\n\nfunction MyComponent({ someKey }) {\n  // Component logic that may throw a JavaScript error\n}\n\nfunction App() {\n  const [someKey, setSomeKey] = React.useState(null)\n\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      onReset={() => setSomeKey(null)} // Reset the application state here\n      resetKeys={[someKey]} // Reset the error boundary when someKey changes\n    >\n      <MyComponent someKey={someKey} />\n    </ErrorBoundary>\n  )\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Eines der m\xe4chtigsten Features von ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," ist die F\xe4higkeit, den Zustand der Fehlergrenze zur\xfcckzusetzen. Dies erm\xf6glicht es, Fehler zu bereinigen und einen erneuten Render-Versuch des Komponentenbaums zu unternehmen. Dies ist besonders n\xfctzlich, wenn Fehler tempor\xe4r sein k\xf6nnten, wie z.B. bei einem vor\xfcbergehenden Netzwerkfehler."]}),"\n",(0,i.jsxs)(n.p,{children:["Die Funktion ",(0,i.jsx)(n.code,{children:"resetErrorBoundary"}),", die der Fallback-Komponente bereitgestellt wird, kann verwendet werden, um die Fehlergrenze zur\xfcckzusetzen. Beispielsweise kann diese Funktion durch einen Button-Klick aufgerufen werden, um dem Benutzer die M\xf6glichkeit zu geben, eine fehlgeschlagene Aktion manuell erneut zu versuchen."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ErrorBoundary"})," kann ",(0,i.jsx)(n.code,{children:"onReset"})," Props akzeptieren, die vor dem Zur\xfccksetzen des Fehlerzustands aufgerufen werden. Diese Funktion kann hilfreich sein, um Bereinigungs- oder Zustandsr\xfccksetzungsaktionen durchzuf\xfchren, bevor die Komponente nach einem Fehler erneut gerendert wird."]}),"\n",(0,i.jsxs)(n.p,{children:["Die ",(0,i.jsx)(n.code,{children:"resetKeys"})," Props sind ein Array von Werten, die die Fehlergrenze zur\xfccksetzen, wenn \xc4nderungen an bestimmten ",(0,i.jsx)(n.code,{children:"props"})," oder Zustandswerten vorgenommen werden. Dies ist n\xfctzlich, wenn \xc4nderungen an bestimmten ",(0,i.jsx)(n.code,{children:"props"})," oder Zustandswerten den Fehler beheben k\xf6nnen. Ein Beispiel f\xfcr die Verwendung dieser Eigenschaften ist wie folgt:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { ErrorBoundary } from 'react-error-boundary'\n\nfunction ErrorFallback({ error, resetErrorBoundary }) {\n  return (\n    <div role=\"alert\">\n      <p>Oops! Etwas ist schief gelaufen:</p>\n      <pre>{error.message}</pre>\n      <button onClick={resetErrorBoundary}>Erneut versuchen</button>\n    </div>\n  )\n}\n\nfunction MyComponent({ someKey }) {\n  // Komponentenlogik, die einen JavaScript-Fehler werfen k\xf6nnte\n}\n\nfunction App() {\n  const [someKey, setSomeKey] = React.useState(null)\n\n  return (\n    <ErrorBoundary\n      FallbackComponent={ErrorFallback}\n      onReset={() => setSomeKey(null)} // Setzen Sie hier den Zustand der Anwendung zur\xfcck\n      resetKeys={[someKey]} // Setzt die Fehlergrenze zur\xfcck, wenn `someKey` ge\xe4ndert wird\n    >\n      <MyComponent someKey={someKey} />\n    </ErrorBoundary>\n  )\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In diesem Beispiel, wenn ein Fehler innerhalb von ",(0,i.jsx)(n.code,{children:"MyComponent"})," gefangen wird, wird die ",(0,i.jsx)(n.code,{children:"ErrorFallback"}),'-Komponente gerendert, um die Fehlermeldung anzuzeigen und einen "Erneut versuchen"-Button bereitzustellen. Wenn dieser Button geklickt wird, wird die ',(0,i.jsx)(n.code,{children:"resetErrorBoundary"}),"-Funktion aufgerufen, um die ",(0,i.jsx)(n.code,{children:"onReset"}),"-Funktion auszul\xf6sen und den Fehlerzustand zu bereinigen, bevor ",(0,i.jsx)(n.code,{children:"MyComponent"})," erneut gerendert wird. Wenn ",(0,i.jsx)(n.code,{children:"someKey"})," ge\xe4ndert wird, wird die Fehlergrenze ebenfalls zur\xfcckgesetzt, was eine flexible Methode bietet, sich von Fehlern zu erholen, basierend auf \xc4nderungen im Zustand der Anwendung."]}),"\n",(0,i.jsx)(n.h3,{id:"useerrorhandler-hook",children:"useErrorHandler Hook"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"react-error-boundary"})," bietet auch einen benutzerdefinierten React-Hook namens ",(0,i.jsx)(n.code,{children:"useErrorHandler"}),", der es erm\xf6glicht, Fehler von \xfcberall in einer Funktionskomponente zu werfen. Die geworfenen Fehler werden von der n\xe4chstgelegenen Fehlergrenze gefangen, \xe4hnlich wie Fehler, die in Lebenszyklusmethoden oder Renderfunktionen von Klassenkomponenten geworfen werden, von Fehlergrenzen gefangen werden."]}),"\n",(0,i.jsxs)(n.p,{children:["Der ",(0,i.jsx)(n.code,{children:"useErrorHandler"}),"-Hook ist besonders n\xfctzlich beim Umgang mit asynchronem Code, da auf diese Weise geworfene Fehler nicht von Komponentenfehlergrenzen gefangen werden. Hier ist ein Beispiel, wie ",(0,i.jsx)(n.code,{children:"useErrorHandler"})," verwendet werden kann:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { useErrorHandler } from 'react-error-boundary'\n\nfunction MyComponent() {\n  const handleError = useErrorHandler()\n\n  async function fetchData() {\n    try {\n      // Daten abrufen\n    } catch (error) {\n      handleError(error)\n    }\n  }\n\n  return {\n    ...\n  };\n}\n\nfunction App() {\n  return (\n    <ErrorBoundary FallbackComponent={ErrorFallback}>\n      <MyComponent />\n    </ErrorBoundary>\n  );\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In diesem Beispiel erh\xe4lt ",(0,i.jsx)(n.code,{children:"MyComponent"})," eine Funktion zur Fehlerbehandlung mithilfe von ",(0,i.jsx)(n.code,{children:"useErrorHandler"}),". Diese Funktion ist in einer asynchronen Funktion enthalten, die Daten abruft und Fehler f\xe4ngt. Wenn ein Fehler auftritt, wird dieser an die ",(0,i.jsx)(n.code,{children:"handleError"}),"-Funktion \xfcbergeben, um den Fehler zu werfen und sicherzustellen, dass er von der ",(0,i.jsx)(n.code,{children:"ErrorBoundary"})," gefangen wird."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"useErrorHandler"})," bietet eine leistungsstarke Methode zur Fehlerbehandlung in Funktionskomponenten und arbeitet nahtlos mit der ",(0,i.jsx)(n.code,{children:"ErrorBoundary"}),"-Komponente von ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," zusammen, um die Fehlerbehandlung in React intuitiver und klarer zu gestalten."]}),"\n",(0,i.jsx)(n.h2,{id:"witherrorboundary-hoc",children:"withErrorBoundary HOC"}),"\n",(0,i.jsxs)(n.p,{children:["Das Paket ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," bietet auch eine L\xf6sung namens ",(0,i.jsx)(n.code,{children:"withErrorBoundary HOC"})," (Higher-Order Component) an. Es handelt sich um einen HOC, der um eine bestimmte Komponente gewickelt wird, um Fehler innerhalb dieser Komponente abzufangen. Der Vorteil dieses Ansatzes ist, dass Sie Fehlergrenzen zu einer Komponente hinzuf\xfcgen k\xf6nnen, ohne die urspr\xfcngliche Implementierung der Komponente zu \xe4ndern und ohne zus\xe4tzliches JSX zum Komponentenbaum hinzuzuf\xfcgen."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { withErrorBoundary } from 'react-error-boundary'\n\nfunction MyComponent() {\n  // Komponentenlogik\n}\n\nconst MyComponentWithErrorBoundary = withErrorBoundary(MyComponent, {\n  FallbackComponent: ErrorFallback,\n  onError: logErrorToService,\n  onReset: handleReset,\n  resetKeys: ['someKey']\n});\n\nfunction App() {\n  return <MyComponentWithErrorBoundary someKey={someKey} />\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In diesem Beispiel wird ",(0,i.jsx)(n.code,{children:"MyComponent"})," mit ",(0,i.jsx)(n.code,{children:"withErrorBoundary"})," umh\xfcllt, um eine Fehlergrenze hinzuzuf\xfcgen. Das zweite Argument von ",(0,i.jsx)(n.code,{children:"withErrorBoundary"})," ist ein Optionsobjekt, das dieselben ",(0,i.jsx)(n.code,{children:"props"})," wie die ",(0,i.jsx)(n.code,{children:"ErrorBoundary"})," Komponente bereitstellen kann: ",(0,i.jsx)(n.code,{children:"FallbackComponent"}),", ",(0,i.jsx)(n.code,{children:"onError"}),", ",(0,i.jsx)(n.code,{children:"onReset"}),", ",(0,i.jsx)(n.code,{children:"resetKeys"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Dieser HOC-Ansatz ist eine elegante L\xf6sung, um Fehlergrenzen zu einer Komponente hinzuzuf\xfcgen, ohne die Implementierung zu \xe4ndern. Es ist besonders n\xfctzlich f\xfcr Klassenkomponenten, bei denen Hooks nicht verwendet werden k\xf6nnen. ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," zeigt Flexibilit\xe4t in der Anpassung an verschiedene Codierungsstile und React-Entwicklungsparadigmen."]}),"\n",(0,i.jsx)(n.h2,{id:"vorteile",children:"Vorteile"}),"\n",(0,i.jsxs)(n.p,{children:["Nachdem wir uns die grundlegende Verwendung von ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," angesehen haben, fassen wir die Vorteile der Verwendung von ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," zusammen."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Benutzerfreundlich: Die Bibliothek bietet eine einfache und intuitive API, abstrahiert die Komplexit\xe4t der Fehlerbehandlung und bietet Entwicklern eine klare und direkte Methode zum Verwalten von Fehlern."}),"\n",(0,i.jsxs)(n.li,{children:["Freundlich zu Funktionskomponenten: Im Gegensatz zu traditionellen React-Fehlergrenzen, die Klassenkomponenten erfordern, ist ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," speziell f\xfcr Funktionskomponenten ausgelegt. Es nutzt Hooks und passt sich dem aktuellen Trend in der React-Entwicklung an."]}),"\n",(0,i.jsx)(n.li,{children:"Flexibilit\xe4t: Die Bibliothek bietet mehrere M\xf6glichkeiten, Fehlergrenzen zu verwenden, einschlie\xdflich Komponenten, Higher-Order Components (HOCs) und benutzerdefinierten Hooks. Diese Flexibilit\xe4t erm\xf6glicht es Entwicklern, die f\xfcr ihre Bed\xfcrfnisse und ihren Codierungsstil am besten geeignete Methode auszuw\xe4hlen."}),"\n",(0,i.jsx)(n.li,{children:"Anpassbare Fallback-UI: Die Bibliothek erm\xf6glicht eine anpassbare Fallback-UI, die angezeigt wird, wenn ein Fehler abgefangen wird. Dies verbessert die Benutzererfahrung gegen\xfcber einem Anwendungsabsturz oder einem leeren Bildschirm."}),"\n",(0,i.jsx)(n.li,{children:"Reset-Funktion: Die Bibliothek erm\xf6glicht das Zur\xfccksetzen des Fehlerzustands, sodass die Anwendung von einem Fehler erholen kann. Diese Funktion ist besonders n\xfctzlich f\xfcr vor\xfcbergehende Fehler, die ohne vollst\xe4ndiges Neuladen der Seite behoben werden k\xf6nnen."}),"\n",(0,i.jsxs)(n.li,{children:["Fehlerberichterstattung: \xdcber die ",(0,i.jsx)(n.code,{children:"onError"}),"-Eigenschaft k\xf6nnen Fehler in einem Fehlerberichtsdienst protokolliert werden, was wertvolle Informationen f\xfcr das Debugging und die Probleml\xf6sung liefert."]}),"\n",(0,i.jsx)(n.li,{children:"Community und Wartung: Die Bibliothek wird in der React-Community weit verbreitet und aktiv gewartet. Daher k\xf6nnen regelm\xe4\xdfige Updates und Verbesserungen erwartet werden."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"fazit",children:"Fazit"}),"\n",(0,i.jsxs)(n.p,{children:["Sowohl bei der Verwendung von Klassenkomponenten als auch von Funktionskomponenten deckt ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," ab. Seine flexible API umfasst Komponenten, High-Order-Komponenten und benutzerdefinierte Hooks und bietet verschiedene M\xf6glichkeiten zur Integration der Fehlerbehandlung in Komponenten. Dar\xfcber hinaus unterst\xfctzt es anpassbare Fallback-Benutzeroberfl\xe4chen, Fehlerzur\xfccksetzungsfunktionen und Fehlerberichte, um eine reibungslose Benutzererfahrung auch bei auftretenden Problemen zu gew\xe4hrleisten."]}),"\n",(0,i.jsxs)(n.p,{children:["Durch die Verwendung von ",(0,i.jsx)(n.code,{children:"react-error-boundary"})," in React-Anwendungen k\xf6nnen Sie eine leistungsstarke Fehlerbehandlung und einfachere Debugging-M\xf6glichkeiten erreichen. Die Nutzung dieser Bibliothek reduziert die Zeit, die f\xfcr das Fehlermanagement aufgewendet wird, und erm\xf6glicht es Ihnen, sich auf den Aufbau herausragender Produktfunktionen zu konzentrieren."]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},7214:(e,n,r)=>{r.d(n,{Z:()=>d,a:()=>s});var i=r(959);const t={},o=i.createContext(t);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);