"use strict";(self.webpackChunkilla_website=self.webpackChunkilla_website||[]).push([[4682],{7877:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>o});var r=t(1527),i=t(7214);const s={title:"Most Practical TypeScript Features",tags:["typescript"],slug:"typescript-most-practical-features-compilation",description:"The importance of type programming in projects goes without saying. This article summarizes some common features of TypeScript to help everyone familiarize and master the use of TypeScript.",authors:["owen"],image:"https://cdn.illacloud.com/illa-website/blog/typescript-most-practical-features-compilation/cover.webp",date:"2024-01-25T10:00"},a=void 0,l={permalink:"/illa-website/blog/typescript-most-practical-features-compilation",source:"@site/blog/typescript-most-practical-features-compilation/typescript-most-practical-features-compilation.md",title:"Most Practical TypeScript Features",description:"The importance of type programming in projects goes without saying. This article summarizes some common features of TypeScript to help everyone familiarize and master the use of TypeScript.",date:"2024-01-25T10:00:00.000Z",formattedDate:"January 25, 2024",tags:[{label:"typescript",permalink:"/illa-website/blog/tags/typescript"}],readingTime:10.515,hasTruncateMarker:!1,authors:[{name:"Owen Chen",title:"CEO",url:"https://github.com/smallSohoSolo",imageURL:"https://avatars.githubusercontent.com/u/7929686?v=4",key:"owen"}],frontMatter:{title:"Most Practical TypeScript Features",tags:["typescript"],slug:"typescript-most-practical-features-compilation",description:"The importance of type programming in projects goes without saying. This article summarizes some common features of TypeScript to help everyone familiarize and master the use of TypeScript.",authors:["owen"],image:"https://cdn.illacloud.com/illa-website/blog/typescript-most-practical-features-compilation/cover.webp",date:"2024-01-25T10:00"},unlisted:!1,prevItem:{title:"Best Web Worker Tutorial",permalink:"/illa-website/blog/web-worker-tutorial"},nextItem:{title:"Best tools for IT Support",permalink:"/illa-website/blog/it-support"},relatedPosts:[],authorPosts:[]},c={authorsImageUrls:[void 0]},o=[{value:"Advanced Types",id:"advanced-types",level:2},{value:"Intersection Types",id:"intersection-types",level:3},{value:"Union Types",id:"union-types",level:3},{value:"String Literal Types",id:"string-literal-types",level:3},{value:"Numeric Literal Types",id:"numeric-literal-types",level:3},{value:"Boolean Literal Types",id:"boolean-literal-types",level:3},{value:"Template Literal Types",id:"template-literal-types",level:3},{value:"Operators",id:"operators",level:2},{value:"keyof",id:"keyof",level:3},{value:"typeof",id:"typeof",level:3},{value:"in",id:"in",level:3},{value:"T[K]",id:"tk",level:3},{value:"Operators",id:"operators-1",level:2},{value:"Non-null Assertion Operator",id:"non-null-assertion-operator",level:3},{value:"Optional Chaining Operator",id:"optional-chaining-operator",level:3},{value:"Nullish Coalescing Operator",id:"nullish-coalescing-operator",level:3},{value:"Numeric Separators",id:"numeric-separators",level:3},{value:"Type Aliases",id:"type-aliases",level:2},{value:"Type Assertions",id:"type-assertions",level:2},{value:"Type Guards",id:"type-guards",level:2},{value:"Generics",id:"generics",level:2},{value:"Introduction to Generics",id:"introduction-to-generics",level:3},{value:"Naming Convention",id:"naming-convention",level:3},{value:"Generic Interface",id:"generic-interface",level:3},{value:"Generic Constraints (extends operator)",id:"generic-constraints-extends-operator",level:3},{value:"Default Generic Parameters",id:"default-generic-parameters",level:3},{value:"Conditional Generics",id:"conditional-generics",level:3},{value:"Generic Inference (infer Operator)",id:"generic-inference-infer-operator",level:3},{value:"Generic Utility Types",id:"generic-utility-types",level:2},{value:"Mapped Types",id:"mapped-types",level:3},{value:"Partial",id:"partial",level:3},{value:"Required",id:"required",level:3},{value:"Readonly",id:"readonly",level:3},{value:"Pick",id:"pick",level:3},{value:"Record",id:"record",level:3},{value:"ReturnType",id:"returntype",level:3},{value:"Exclude",id:"exclude",level:3},{value:"Extract",id:"extract",level:3},{value:"Omit",id:"omit",level:3},{value:"NonNullable",id:"nonnullable",level:3},{value:"Parameters",id:"parameters",level:3},{value:"Conclusion",id:"conclusion",level:2}];function p(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"The importance of type programming in projects goes without saying. This article will summarize some common features of TypeScript, helping everyone to familiarize and master its use."}),"\n",(0,r.jsx)(n.h2,{id:"advanced-types",children:"Advanced Types"}),"\n",(0,r.jsx)(n.h3,{id:"intersection-types",children:"Intersection Types"}),"\n",(0,r.jsx)(n.p,{children:"Intersection types combine multiple types into one using the & symbol."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'interface I1 {\n  name: string;\n}\n\ninterface I2 {\n  age: number;\n}\n\ntype T3 = I1 & I2\n\nconst a: T3 = {\n  name: "tj",\n  age: 11,\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"union-types",children:"Union Types"}),"\n",(0,r.jsx)(n.p,{children:"Union types, indicated by the | symbol, mean a value can be one of several types."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const a: string | number = 1\n"})}),"\n",(0,r.jsx)(n.h3,{id:"string-literal-types",children:"String Literal Types"}),"\n",(0,r.jsx)(n.p,{children:"String literal types use a string type as the type of a variable."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const a: 'number' = 'number'\n"})}),"\n",(0,r.jsx)(n.h3,{id:"numeric-literal-types",children:"Numeric Literal Types"}),"\n",(0,r.jsx)(n.p,{children:"Numeric literal types use a number as the type of a variable."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const a: 1 = 1\n"})}),"\n",(0,r.jsx)(n.h3,{id:"boolean-literal-types",children:"Boolean Literal Types"}),"\n",(0,r.jsx)(n.p,{children:"Boolean literal types use a boolean value as the type of a variable."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const a: true = true\n"})}),"\n",(0,r.jsx)(n.h3,{id:"template-literal-types",children:"Template Literal Types"}),"\n",(0,r.jsx)(n.p,{children:"Template literal types use ES6 template string syntax to constrain types."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type https = `https://${string}`\nconst a:https = `https://jd.com`\n"})}),"\n",(0,r.jsx)(n.h2,{id:"operators",children:"Operators"}),"\n",(0,r.jsx)(n.h3,{id:"keyof",children:"keyof"}),"\n",(0,r.jsx)(n.p,{children:"keyof is used to get all keys of a type, returning a union type."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// const a: 'name' | 'age' = 'name'\nconst a: keyof {\nname: string,\nage: number\n} = 'name'\n"})}),"\n",(0,r.jsx)(n.h3,{id:"typeof",children:"typeof"}),"\n",(0,r.jsx)(n.p,{children:"typeof is used to get the structural type of an object or function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const a2 = {\nname: 'tj',\n}\n\ntype T1 = typeof a2 // {name: string}\n\nfunction fn1(x: number): number {\nreturn x * 10\n}\n\ntype T2 = typeof fn1 // (x: number) => number\n"})}),"\n",(0,r.jsx)(n.h3,{id:"in",children:"in"}),"\n",(0,r.jsx)(n.p,{children:"in is used to iterate over union types."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const obj = {\n  name: "tj",\n  age: 11,\n}\n\ntype T5 = {\n  [P in keyof typeof obj]: any\n}\n\n/*\n{\nname: any,\nage: any\n}\n*/\n'})}),"\n",(0,r.jsx)(n.h3,{id:"tk",children:"T[K]"}),"\n",(0,r.jsx)(n.p,{children:"T[K] is used to access an index, obtaining the union type of the corresponding value."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface I3 {\n  name: string,\n  age: number\n}\ntype T6 = I3[keyof I3] // string | number\n\n"})}),"\n",(0,r.jsx)(n.h2,{id:"operators-1",children:"Operators"}),"\n",(0,r.jsx)(n.h3,{id:"non-null-assertion-operator",children:"Non-null Assertion Operator"}),"\n",(0,r.jsx)(n.p,{children:"The non-null assertion operator ! is used to emphasize that an element is neither null nor undefined, informing TypeScript that the property will be explicitly assigned."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"function Demo(): JSX.Element () {\n   const divRef = useRef<HTMLDivElement>()\n   useEffect(() => {\n      divRef.current!.scrollIntoView() // Asserting that divRef.current is not null or undefined\n   }, [])\n   return <div ref={divRef}>divDemo</div>\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"optional-chaining-operator",children:"Optional Chaining Operator"}),"\n",(0,r.jsx)(n.p,{children:"The optional chaining operator ?. is used to check if the left-hand expression is null or undefined, stopping the expression if true."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const a = b?.a\n"})}),"\n",(0,r.jsx)(n.h3,{id:"nullish-coalescing-operator",children:"Nullish Coalescing Operator"}),"\n",(0,r.jsx)(n.p,{children:"The nullish coalescing operator ?? is used to check if the left-hand expression is null or undefined, returning the right-hand value if not."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const a = b ?? 10\n"})}),"\n",(0,r.jsx)(n.h3,{id:"numeric-separators",children:"Numeric Separators"}),"\n",(0,r.jsx)(n.p,{children:"Numeric separators _ are used to split long numbers for easier reading. The compiled result will automatically remove _."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const num: number = 1_111_111_111\n"})}),"\n",(0,r.jsx)(n.h2,{id:"type-aliases",children:"Type Aliases"}),"\n",(0,r.jsx)(n.p,{children:"Type aliases are used to give a type a new name."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Message = string | string[]\nlet greet = (message: Message) => {\n// ...\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"type-assertions",children:"Type Assertions"}),"\n",(0,r.jsx)(n.p,{children:"Type assertions tell the browser what type I am very certain of."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Angle bracket syntax\nlet someValue: any = "this is a string";\nlet strLength: number = (<string>someValue).length;\n\n// as syntax\nlet someValue: any =\n\n "this is a string";\nlet strLength: number = (someValue as string).length;\n'})}),"\n",(0,r.jsx)(n.h2,{id:"type-guards",children:"Type Guards"}),"\n",(0,r.jsx)(n.p,{children:"Type guards are expressions that check types at runtime to ensure the type within a certain scope."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'interface A {\n  name: string;\n  age: number;\n}\n\ninterface B {\n  sex: string;\n  home: string;\n}\n\nfunction doSomething(person: A | B): void {\n  if (person.name) {\n// Error\n// ...\n  }\n}\n\n// Using in type guard\nfunction doSomething(person: A | B): void {\n  if ("name" in person) {\n// OK\n// ...\n  }\n}\n\n// Using typeof type guard\nfunction A(a: string | number): string | number {\n  if (typeof a === "string") {\n// OK\n    return a + ""\n  }\n  if (typeof a === "number") {\n// OK\n    return a + 2\n  }\n  return ""\n}\n\n// instanceof type guard\nclass Foo {\n}\n\nclass Bar {\n}\n\nfunction test(input: Foo | Bar) {\n  if (input instanceof Foo) {\n// Here input type \'narrows\' to Foo\n  } else {\n// Here input type \'narrows\' to Bar\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"generics",children:"Generics"}),"\n",(0,r.jsx)(n.h3,{id:"introduction-to-generics",children:"Introduction to Generics"}),"\n",(0,r.jsx)(n.p,{children:"Generics are like passing parameters to types to get a more general type, just like passing parameters to functions."}),"\n",(0,r.jsx)(n.p,{children:"As shown below, we get a general generic type T1, which can become T2 type string[] and T3 type number[] through passing parameters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type T1<T> = T[]\ntype T2 = T1<string> // string[]\ntype T3 = T1<number> // number[]\n"})}),"\n",(0,r.jsx)(n.p,{children:"As above, T is a variable, and we can replace it with any other variable name."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type T4<A> = A[]\ntype T5 = T4<string> // string[]\ntype T6 = T4<number> // number[]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"naming-convention",children:"Naming Convention"}),"\n",(0,r.jsx)(n.p,{children:"In the TypeScript generic variable naming convention, 4 common generic variable names are defaulted. To improve readability, it is not recommended to define them as other variable names."}),"\n",(0,r.jsx)(n.p,{children:"T: Represents the first parameter\nK: Represents the key type of the object\nV: Represents the value type of the object\nE: Represents the element type"}),"\n",(0,r.jsx)(n.h3,{id:"generic-interface",children:"Generic Interface"}),"\n",(0,r.jsx)(n.p,{children:"Generic interfaces, similar to the examples above, pass parameters to interface types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface I1<T, U> {\n  name: T;\n  age: U;\n}\ntype I2 = I1<string, number>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"generic-constraints-extends-operator",children:"Generic Constraints (extends operator)"}),"\n",(0,r.jsx)(n.p,{children:"Sometimes, we need to constrain generic parameters, limiting each variable's type. TypeScript implements type constraints through extends."}),"\n",(0,r.jsx)(n.p,{children:"Generic constraint syntax is as follows:"}),"\n",(0,r.jsx)(n.p,{children:"Generic name extends type\nT extends Length constraints T's type to include the length property, and the type of length must be number."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface Length {\n  length: number\n}\n\nfunction fn1<T extends Length>(arg: T): number {\n  return arg.length\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"K is constrained by extends to be a key of T."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key]\n}\n\nlet tsInfo = {\n  name: "Typescript",\n  supersetOf: "Javascript",\n  difficulty: Difficulty.Intermediate,\n}\n\nlet difficulty: Difficulty =\n  getProperty(tsInfo, "difficulty") // OK\n\nlet supersetOf: string =\n  getProperty(tsInfo, "superset_of") // Error\n\n'})}),"\n",(0,r.jsx)(n.h3,{id:"default-generic-parameters",children:"Default Generic Parameters"}),"\n",(0,r.jsx)(n.p,{children:"Generic parameters default values, like function parameter default values, are given default values when not passed."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'interface I4<T = string> {\n  name: T;\n}\n\nconst S1: I4 = { name: "123" } // By default name: string type\nconst S2: I4<number> = { name: 123 }\n'})}),"\n",(0,r.jsx)(n.h3,{id:"conditional-generics",children:"Conditional Generics"}),"\n",(0,r.jsx)(n.p,{children:"Conditional types mean the same as conditional judgments in Js, which is if the condition is met, then xx, otherwise xx."}),"\n",(0,r.jsx)(n.p,{children:"Conditional type expression:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"T extends U ? X : Y\n"})}),"\n",(0,r.jsx)(n.p,{children:"If T can be assigned to U, then the type is X, otherwise the type is Y."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type T1<T> = T extends string ? 'string' : 'number'\ntype T2 = T1<string> // 'string'\ntype T3 = T1<number> // 'number\n"})}),"\n",(0,r.jsx)(n.h3,{id:"generic-inference-infer-operator",children:"Generic Inference (infer Operator)"}),"\n",(0,r.jsxs)(n.p,{children:["The keyword for generic inference is ",(0,r.jsx)(n.code,{children:"infer"}),", and the syntax is ",(0,r.jsx)(n.code,{children:"infer Type"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"It is generally used in combination with generic conditional types. To understand this, consider a practical example:"}),"\n",(0,r.jsxs)(n.p,{children:["If the generic parameter ",(0,r.jsx)(n.code,{children:"T"})," can be assigned to the type ",(0,r.jsx)(n.code,{children:"{t: infer Test}"}),", then the type is the inferred type ",(0,r.jsx)(n.code,{children:"Test"}),", otherwise, the type is ",(0,r.jsx)(n.code,{children:"string"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Foo<T> = T extends {t: infer Test} ? Test : string\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The generic parameter ",(0,r.jsx)(n.code,{children:"number"})," does not have a ",(0,r.jsx)(n.code,{children:"t"})," property, so the type is ",(0,r.jsx)(n.code,{children:"string"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type One = Foo<number> // string\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"t"})," property of the generic parameter is ",(0,r.jsx)(n.code,{children:"boolean"}),", so the type is the inferred type ",(0,r.jsx)(n.code,{children:"boolean"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Two = Foo<{ t: boolean }> // boolean\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"t"})," property of the generic parameter is ",(0,r.jsx)(n.code,{children:"() => void"}),", so the type is the inferred type ",(0,r.jsx)(n.code,{children:"() => void"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Three = Foo<{ a: number, t: () => void }> // () => void\n"})}),"\n",(0,r.jsx)(n.h2,{id:"generic-utility-types",children:"Generic Utility Types"}),"\n",(0,r.jsx)(n.h3,{id:"mapped-types",children:"Mapped Types"}),"\n",(0,r.jsx)(n.p,{children:"Mapped types are a kind of generic type that can be used to map an existing object type into a new object type."}),"\n",(0,r.jsx)(n.p,{children:"Common syntax for mapped types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"{ [ P in K ] : T }\n{ [ P in K ] ?: T }\n{ [ P in K ] -?: T }\n{ readonly [ P in K ] : T }\n{ readonly [ P in K ] ?: T }\n{ -readonly [ P in K ] ?: T }\n"})}),"\n",(0,r.jsx)(n.p,{children:"For example, making all properties optional using mapped types:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"partial",children:"Partial"}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript has encapsulated some common mapped types, such as ",(0,r.jsx)(n.code,{children:"Partial"}),", which is used to make all properties of a generic optional."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n\ntype T1 = Partial<{\n  name: string,\n}>\n\nconst a: T1 = {} // No error without the name property\n"})}),"\n",(0,r.jsx)(n.h3,{id:"required",children:"Required"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Required"})," makes all properties of the generic required."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'type Required<T> = {\n  [P in keyof T]-?: T[P]\n}\n\ntype T2 = Required<{\n  name?: string,\n}>\n\nconst b: T2 = {} // TypeScript error, the type "{}" lacks the property "name", but it is required in "Required<{ name?: string | undefined; }>". ts(2741)\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The syntax ",(0,r.jsx)(n.code,{children:"-?"})," means to remove the optional ",(0,r.jsx)(n.code,{children:"?"})," property."]}),"\n",(0,r.jsx)(n.h3,{id:"readonly",children:"Readonly"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Readonly"})," makes all properties of the generic read-only."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'type T3 = Readonly<{\n  name: string,\n}>\n\nconst c: T3 = {\n  name: "tj",\n}\n\nc.name = "tj1" // TypeScript error, cannot assign to "name" because it is a read-only property. ts(2540)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"pick",children:"Pick"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Pick"})," selects certain properties from a type to create a new type."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'type Pick<T, K extends keyof T> = {\n  [P in K]: T[P]\n}\n\ntype T4 = Pick<\n  {\n    name: string,\n    age: number,\n  },\n  "name"\n>\n\n/*\nThis is a new type, T4 = {name: string}\n*/\n\nconst d: T4 = {\n  name: "tj",\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"record",children:"Record"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Record"})," converts keys and values into type ",(0,r.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Record<K extends keyof any, T> = {\n  [key in K]: T\n}\nconst e: Record<string, string> = {\n  name: 'tj',\n}\n\nconst f: Record<string, number> = {\n  age: 11,\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"keyof any"})," corresponds to types ",(0,r.jsx)(n.code,{children:"number | string | symbol"}),", which are the collection of types that can be object keys."]}),"\n",(0,r.jsx)(n.h3,{id:"returntype",children:"ReturnType"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ReturnType"})," gets the return type corresponding to type ",(0,r.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any\n"})}),"\n",(0,r.jsx)(n.h3,{id:"exclude",children:"Exclude"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Exclude"})," removes types in one type that are part of another."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'type Exclude<T, U> = T extends U ? never : T;\ntype T0 = Exclude<"a" | "b" | "c", "a">; // "b" | "c"\ntype T1 = Exclude<"a" | "b" | "c", "a" | "b">; // "c"\ntype T2 = Exclude<string | number | (() => void), Function>;\n\n // string | number\n'})}),"\n",(0,r.jsx)(n.h3,{id:"extract",children:"Extract"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Extract"})," extracts type ",(0,r.jsx)(n.code,{children:"U"})," from ",(0,r.jsx)(n.code,{children:"T"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'type Extract<T, U> = T extends U ? T : never;\ntype T0 = Extract<"a" | "b" | "c", "a" | "f">; // "a"\ntype T1 = Extract<string | number | (() => void), Function>; // () => void\n'})}),"\n",(0,r.jsx)(n.h3,{id:"omit",children:"Omit"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Omit"})," constructs a new type using all properties from type ",(0,r.jsx)(n.code,{children:"T"})," except those in type ",(0,r.jsx)(n.code,{children:"K"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n\ninterface Todo {\n  title: string;\n  completed: boolean;\n  description: string;\n}\n\ntype TodoPreview = Omit<Todo, "description">;\n\n/*\n{\ntitle: string;\ncompleted: boolean;\n}\n*/\n'})}),"\n",(0,r.jsx)(n.h3,{id:"nonnullable",children:"NonNullable"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"NonNullable"})," is used to filter out ",(0,r.jsx)(n.code,{children:"null"})," and ",(0,r.jsx)(n.code,{children:"undefined"})," from a type."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type NonNullable<T> = T extends null | undefined ? never : T;\ntype T0 = NonNullable<string | number | undefined>; // string | number\ntype T1 = NonNullable<string[] | null | undefined>; // string[]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Parameters"})," is used to get the tuple type composed of a function's parameter types."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any\n? P : never;\n\ntype A = Parameters<() => void>; // []\ntype B = Parameters<typeof Array.isArray>; // [any]\ntype C = Parameters<typeof parseInt>; // [string, (number | undefined)?]\ntype D = Parameters<typeof Math.max>; // number[]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"Bookmark this now!"})]})}function d(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},7214:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>a});var r=t(959);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);